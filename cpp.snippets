# A valid snippet should starts with:
#
#		snippet trigger_word [ "description" [ options ] ]
#
# and end with:
#
#		endsnippet
#
# Snippet options:
#
#		b - Beginning of line.
#		i - In-word expansion.
#		w - Word boundary.
#		r - Regular expression
#		e - Custom context snippet
#		A - Snippet will be triggered automatically, when condition matches.
#
# Basic example:
#
#		snippet emitter "emitter properties" b
#		private readonly ${1} = new Emitter<$2>()
#		public readonly ${1/^_(.*)/$1/}: Event<$2> = this.$1.event
#		endsnippet
#
# Online reference: https://github.com/SirVer/ultisnips/blob/master/doc/UltiSnips.txt

# =========================================================
# const
# =========================================================
snippet sni_const_PI "PI" b
double PI = acos(-1);
endsnippet

snippet sni_const_INFINITY_INT "INFINITY" b
const int INF = 1001001001;
endsnippet

snippet sni_const_INFINITY_LONG "INFINITY" b
const long long INF = 1001001001001001001;
endsnippet

snippet sni_const_MOD_998244353 "mod" b
const int MOD = 998244353;
endsnippet

snippet sni_const_MOD_100000007 "mod" b
const int MOD = 100000007;
endsnippet

# =========================================================
# STL
# =========================================================
snippet trans "transform" b
std::transform(${1:str}.begin(), $1.end(), $1.begin(), ::${2:tolower});
endsnippet

snippet sort_Asc "asc" b
sort(${1:s}.begin(), $1.end());
endsnippet

snippet sort_Desc "desc" b
sort(${1:s}.rbegin(), $1.rend());
endsnippet

snippet uni "unique" b
sort(${1:A}.begin(), $1.end());
A.erase(unique($1.begin(), $1.end()), $1.end());
endsnippet

# =========================================================
# Algorithm
# =========================================================
snippet sni_algo_is_prime "is prime" b
auto is_prime = [](int num) -> bool {
	if (num == 2) return true;
	if (num < 2 || num % 2 == 0) return false;
	double sqrtNum = sqrt(num);
	for (int i = 3; i <= sqrtNum; i += 2) {
		if (num % i == 0) return false;
	}
	return true;
};
endsnippet

snippet sni_algo_eratosthenes_sieve "sieve if eratosthenes" b
vector<int> is_P(N + 1, true);
is_P[0] = is_P[1] = false;
for (int i = 2; i * i <= N; i++) {
	if (!is_P[i]) continue;
	for (int j = i * i; j <= N; j += i) is_P[j] = false;
}
endsnippet

snippet sni_algo_modpow "modpow" b
auto modpow = [](long long a, long long n, long long mod) -> long long {
	long long res = 1;
	while (n > 0) {
		if (n & 1) res = res * a % mod;
		a = a * a % mod;
		n >>= 1;
	}
	return res;
};
endsnippet

snippet sni_algo_inverse_Fermat "Fermat" b
auto modinv = [&](long long a, long long mod) -> long long { return modpow(a, mod - 2, mod); };
endsnippet

snippet sni_algo_inverse_Euclid "extended Euclid" b
auto modinv = [](long long a, long long m) -> long long {
	long long b = m, u = 1, v = 0;
	while (b) {
		long long t = a / b;
		a -= t * b;
		swap(a, b);
		u -= t * v;
		swap(u, v);
	}
	u %= m;
	if (u < 0) u += m;
	return u;
};
endsnippet

snippet sni_algo_bit_loop "bit loop" b
for (int bit = 0; bit < 1 << N; bit++) {
	vector<int> tmp;
	for (int i = 0; i < N; i++) if (bit & (1 << i)) tmp.push_back(i);
	//
}
endsnippet

snippet sni_algo_2point_Shyakutori "shakutori" b
int ans = 0, cur = 0;
for (int i = 0; i < N; i++) {
	while (cur < N and A[cur] < A[i] + M) ++cur;
	ans = max(ans, cur - i);
}
endsnippet

snippet sni_algo_bfs_graph_1d "bfs graph support" b
vector<vector<${1:int}>> Graph(N, vector<$1>(1, 0));
queue<$1> q;
vector<${2:int}> dist(N, -1);
//vector<bool> used(N, false);
//vector<int> counter(N + 1, 0);

for (int i = 0; i < N; i++) {
	$1 a, b;
	cin >> a >> b;
	Graph[a].push_back(b);
	Graph[b].push_back(a);
}

q.push(0);
dist[0] = 0;

while (!q.empty()) {
	$1 current_vertex = q.front();
	q.pop();
	for ($1 next_vertex : Graph[current_vertex]) {
		if (dist[next_vertex] == -1) continue;
		dist[next_vertex] = dist[current_vertex] + 1;
		q.push(next_vertex);
	}
}
endsnippet

snippet sni_algo_bfs_grid_2d "bfs grid support" b
//vector<string> Grid(row);
vector<vector<char>> Grid(row, vector<char>(column, '.'));
vector<int> dx4 = {1, 0, -1, 0};
vector<int> dy4 = {0, 1, 0, -1};
vector<int> dx8 = {-1, -1, -1, 0, 0, 1, 1, 1};
vector<int> dy8 = {-1, 0, 1, -1, 1, -1, 0, 1};
queue<pair<int, int>> q;
vector<vector<bool>> used(row, vector<bool>(column, false));
//vector<vector<int>> dist(row, vector<int>(column, -1));

q.push({0, 0});
used[0][0] = true;
//dist[0][0] = 0;

while (!q.empty()) {
	pair<int, int> current_xy = q.front();
	q.pop();
	for (int i = 0; i < 8; i++) {
		int x = dx8[i] + current_xy.first;
		int y = dy8[i] + current_xy.second;
		// only in range
		if (x < 0 or y < 0 or column <= x or row <= y) continue;
		// un visited, can go
		if (!used[x][y] and Grid[x][y] == '#') {
			q.push({x, y});
			used[x][y] = true;
			//dist[x][y] = dist[current_xy.first][current_xy.second] + 1;
		}
	}
}
endsnippet

snippet sni_algo_dp_napsack "dp napsack support" b
vector<vector<int>> dp(N + 1, vector<int>(W + 1, 0));
for (int i = 0; i < N; i++) {
	int wi = weight[i];
	int vi = value[i];
	for (int w = 0; w <= W; ++w) {
		if (w < wi) {
			dp[i + 1][w] = dp[i][w];
		} else {
			dp[i + 1][w] = max(dp[i][w], dp[i][w - wi] + vi);
		}
	}
}
endsnippet

snippet sni_algo_dp_sum_partial "dp partial sum support" b
vector<vector<int>> dp(N + 1, vector<int>(K + 1, false));
dp[0][0] = true;
for (int i = 0; i < N; i++) {
	int ai = A[i];
	for (int k = 0; k <= K; ++k) {
		dp[i + 1][k] = dp[i][k];
		if (k >= ai) {
			dp[i + 1][k] = dp[i][k] or dp[i][k - ai];
		}
	}
}
endsnippet

snippet sni_algo_cmopress "compress" b
auto compress = []<class T>(vector<T> &vec) -> void {
	auto v = vec;
	sort(v.begin(), v.end());
	v.erase(unique(v.begin(), v.end()), v.end());
	for (int i = 0; i < (int)vec.size(); i++) {
		 vec[i] = lower_bound(v.begin(), v.end(), vec[i]) - v.begin();
	}
};
endsnippet

snippet sni_algo_Seg_RMQ "Segment Tree RMQ" b
class SegmentTreeRMQ {
	const static long long ll_MAX = (1LL << 31) - 1;
	int n_0; long long seg_tree[4 * 100007];
  public:
	SegmentTreeRMQ(int n) {
		n_0 = 1; while (n_0 < n) n_0 <<= 1;
		for (int i = 0; i < 2 * n_0; i++) {
			seg_tree[i] = ll_MAX;
		}
	}
	void update(int idx, long long val) {
		idx += n_0 - 1; seg_tree[idx] = val;
		while (idx > 0) { idx = (idx - 1) / 2; seg_tree[idx] = min(seg_tree[2 * idx + 1], seg_tree[2 * idx + 2]); }
	}
	long long query(int l, int r) {
		int l_0 = l + n_0, r_0 = r + n_0; long long s = ll_MAX;
		while (l_0 < r_0) { if (r_0 & 1) { --r_0; s = min(s, seg_tree[r_0 - 1]); }
			if (l_0 & 1) { s = min(s, seg_tree[l_0 - 1]); ++l_0; }
			l_0 >>= 1; r_0 >>= 1; } return s;
	}
};
endsnippet

# =========================================================
# grammer
# =========================================================
snippet fori "for" b
for (${1:int} ${2:i}=${3:0}; $2<${4:N}; ${5:$2++}) {
	${6}
}
endsnippet

snippet forv "for vector" b
for (${1:int} ${2:v} : ${3:A}) {
	${4}
}
endsnippet

snippet func "function" b
${1:void} ${2:func}(${3:int n}) {
	${4}
}
endsnippet

snippet func_lambda "function lambda" b
auto ${1:func} = [&](${2:int a}) -> ${3:void} {
	${4}
};
endsnippet

snippet func_recursive "function recursive" b
auto ${1:func} = [&](auto self, ${2:int a}) -> ${3:void} {
	${4}
	self(self, $2); // recursive
};

// TODO
$1($1, );
endsnippet

# =========================================================
# Template
# =========================================================
snippet xxx "template cpp for AtCoder" bA
#include <bits/stdc++.h>
using namespace std;
int main() {
	${1}
}
endsnippet

